'use strict';
(function(global){const EPSILON=1e-10,PI=Math.PI,PI2=PI*2,DEG2RAD=PI/180,RAD2DEG=180/PI;
class V2{constructor(x=0,y=0){this.x=x;this.y=y}clone(){return new V2(this.x,this.y)}add(v){return new V2(this.x+v.x,this.y+v.y)}sub(v){return new V2(this.x-v.x,this.y-v.y)}mul(s){return new V2(this.x*s,this.y*s)}div(s){const is=1/s;return new V2(this.x*is,this.y*is)}dot(v){return this.x*v.x+this.y*v.y}cross(v){return this.x*v.y-this.y*v.x}len(){return Math.sqrt(this.x*this.x+this.y*this.y)}len2(){return this.x*this.x+this.y*this.y}norm(){const l=this.len();return l>EPSILON?this.div(l):new V2(0,0)}perp(){return new V2(-this.y,this.x)}rot(a){const c=Math.cos(a),s=Math.sin(a);return new V2(this.x*c-this.y*s,this.x*s+this.y*c)}dist(v){return this.sub(v).len()}dist2(v){return this.sub(v).len2()}lerp(v,t){return this.add(v.sub(this).mul(t))}reflect(n){return this.sub(n.mul(2*this.dot(n)))}set(x,y){this.x=x;this.y=y;return this}neg(){return new V2(-this.x,-this.y)}}
class V3{constructor(x=0,y=0,z=0){this.x=x;this.y=y;this.z=z}clone(){return new V3(this.x,this.y,this.z)}add(v){return new V3(this.x+v.x,this.y+v.y,this.z+v.z)}sub(v){return new V3(this.x-v.x,this.y-v.y,this.z-v.z)}mul(s){return new V3(this.x*s,this.y*s,this.z*s)}div(s){const is=1/s;return new V3(this.x*is,this.y*is,this.z*is)}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z}cross(v){return new V3(this.y*v.z-this.z*v.y,this.z*v.x-this.x*v.z,this.x*v.y-this.y*v.x)}len(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}len2(){return this.x*this.x+this.y*this.y+this.z*this.z}norm(){const l=this.len();return l>EPSILON?this.div(l):new V3(0,0,0)}dist(v){return this.sub(v).len()}dist2(v){return this.sub(v).len2()}lerp(v,t){return this.add(v.sub(this).mul(t))}reflect(n){return this.sub(n.mul(2*this.dot(n)))}set(x,y,z){this.x=x;this.y=y;this.z=z;return this}neg(){return new V3(-this.x,-this.y,-this.z)}}
class M3{constructor(){this.m=[1,0,0,0,1,0,0,0,1]}static identity(){return new M3()}static rotation(angle){const m=new M3(),c=Math.cos(angle),s=Math.sin(angle);m.m[0]=c;m.m[1]=-s;m.m[3]=s;m.m[4]=c;return m}static scale(sx,sy){const m=new M3();m.m[0]=sx;m.m[4]=sy;return m}mulV(v){const m=this.m;return new V2(m[0]*v.x+m[1]*v.y+m[2],m[3]*v.x+m[4]*v.y+m[5])}mul(n){const a=this.m,b=n.m,m=new M3();m.m[0]=a[0]*b[0]+a[1]*b[3]+a[2]*b[6];m.m[1]=a[0]*b[1]+a[1]*b[4]+a[2]*b[7];m.m[2]=a[0]*b[2]+a[1]*b[5]+a[2]*b[8];m.m[3]=a[3]*b[0]+a[4]*b[3]+a[5]*b[6];m.m[4]=a[3]*b[1]+a[4]*b[4]+a[5]*b[7];m.m[5]=a[3]*b[2]+a[4]*b[5]+a[5]*b[8];m.m[6]=a[6]*b[0]+a[7]*b[3]+a[8]*b[6];m.m[7]=a[6]*b[1]+a[7]*b[4]+a[8]*b[7];m.m[8]=a[6]*b[2]+a[7]*b[5]+a[8]*b[8];return m}}
class M4{constructor(){this.m=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}static perspective(fov,aspect,near,far){const m=new M4(),f=1/Math.tan(fov/2),nf=1/(near-far);m.m[0]=f/aspect;m.m[5]=f;m.m[10]=(far+near)*nf;m.m[11]=-1;m.m[14]=2*far*near*nf;m.m[15]=0;return m}static lookAt(eye,target,up){const z=eye.sub(target).norm(),x=up.cross(z).norm(),y=z.cross(x);const m=new M4();m.m[0]=x.x;m.m[1]=y.x;m.m[2]=z.x;m.m[4]=x.y;m.m[5]=y.y;m.m[6]=z.y;m.m[8]=x.z;m.m[9]=y.z;m.m[10]=z.z;m.m[12]=-x.dot(eye);m.m[13]=-y.dot(eye);m.m[14]=-z.dot(eye);return m}mulV(v){const m=this.m,w=m[12]*v.x+m[13]*v.y+m[14]*v.z+m[15];return new V3((m[0]*v.x+m[1]*v.y+m[2]*v.z+m[3])/w,(m[4]*v.x+m[5]*v.y+m[6]*v.z+m[7])/w,(m[8]*v.x+m[9]*v.y+m[10]*v.z+m[11])/w)}}
function clamp(v,a,b){return v<a?a:v>b?b:v}function lerp(a,b,t){return a+(b-a)*t}function smoothstep(a,b,t){const x=clamp((t-a)/(b-a),0,1);return x*x*(3-2*x)}
class AABB{constructor(min,max){this.min=min;this.max=max}overlaps(b){const a=this;if(a.min instanceof V2)return!(a.max.x<b.min.x||a.min.x>b.max.x||a.max.y<b.min.y||a.min.y>b.max.y);return!(a.max.x<b.min.x||a.min.x>b.max.x||a.max.y<b.min.y||a.min.y>b.max.y||a.max.z<b.min.z||a.min.z>b.max.z)}expand(amt){return this.min instanceof V2?new AABB(this.min.sub(new V2(amt,amt)),this.max.add(new V2(amt,amt))):new AABB(this.min.sub(new V3(amt,amt,amt)),this.max.add(new V3(amt,amt,amt)))}center(){return this.min instanceof V2?this.min.add(this.max).mul(0.5):this.min.add(this.max).mul(0.5)}size(){return this.min instanceof V2?this.max.sub(this.min):this.max.sub(this.min)}}
class Material{constructor(opt={}){this.restitution=opt.restitution??0.5;this.staticFriction=opt.staticFriction??0.6;this.dynamicFriction=opt.dynamicFriction??0.4;this.density=opt.density??1.0;this.color=opt.color||'#4488ff';this.roughness=opt.roughness??0.5;this.metalness=opt.metalness??0.0}}
class Shape{constructor(type){this.type=type}computeMass(density){return 1}computeInertia(mass){return 1}getAABB(pos,angle){return new AABB(new V2(0,0),new V2(0,0))}}
class Circle extends Shape{constructor(r){super('circle');this.r=r}computeMass(d){return Math.PI*this.r*this.r*d}computeInertia(m){return 0.5*m*this.r*this.r}getAABB(p,a){const r=new V2(this.r,this.r);return new AABB(p.sub(r),p.add(r))}}
class Box extends Shape{constructor(w,h){super('box');this.w=w;this.h=h}computeMass(d){return this.w*this.h*d}computeInertia(m){return m*(this.w*this.w+this.h*this.h)/12}getAABB(p,a){const hw=this.w/2,hh=this.h/2;if(Math.abs(a)<EPSILON)return new AABB(p.sub(new V2(hw,hh)),p.add(new V2(hw,hh)));const c=Math.cos(a),s=Math.sin(a),x=Math.abs(hw*c)+Math.abs(hh*s),y=Math.abs(hw*s)+Math.abs(hh*c);return new AABB(p.sub(new V2(x,y)),p.add(new V2(x,y)))}}
class Sphere extends Shape{constructor(r){super('sphere');this.r=r}computeMass(d){return 4/3*Math.PI*this.r*this.r*this.r*d}computeInertia(m){return 0.4*m*this.r*this.r}getAABB(p){const r=new V3(this.r,this.r,this.r);return new AABB(p.sub(r),p.add(r))}}
class Cube extends Shape{constructor(w,h,d){super('cube');this.w=w;this.h=h;this.d=d}computeMass(den){return this.w*this.h*this.d*den}computeInertia(m){return m*(this.w*this.w+this.h*this.h+this.d*this.d)/12}getAABB(p){const hw=this.w/2,hh=this.h/2,hd=this.d/2;return new AABB(p.sub(new V3(hw,hh,hd)),p.add(new V3(hw,hh,hd)))}}
let bodyIdCounter=0;
class Body{constructor(opt={}){this.id=bodyIdCounter++;this.dim=opt.dim||'2D';this.shape=opt.shape;this.pos=opt.pos?opt.pos.clone():(this.dim==='2D'?new V2():new V3());this.vel=opt.vel?opt.vel.clone():(this.dim==='2D'?new V2():new V3());this.acc=this.dim==='2D'?new V2():new V3();this.angle=opt.angle||0;this.angVel=opt.angularVelocity||0;this.angAcc=0;this.force=this.dim==='2D'?new V2():new V3();this.torque=0;this.mat=opt.material||new Material();this.mass=opt.mass??this.shape.computeMass(this.mat.density);this.invMass=this.mass>0?1/this.mass:0;this.inertia=opt.inertia??this.shape.computeInertia(this.mass);this.invInertia=this.inertia>0?1/this.inertia:0;this.isStatic=opt.static||false;if(this.isStatic){this.invMass=0;this.invInertia=0}this.isSleeping=false;this.sleepTime=0;this.velThreshold=0.01;this.userData={}}applyForce(f,p){if(this.isStatic)return;this.force=this.force.add(f);if(p&&this.dim==='2D'){const r=p.sub(this.pos);this.torque+=r.cross(f)}}applyImpulse(j,p){if(this.isStatic)return;this.vel=this.vel.add(j.mul(this.invMass));if(p&&this.dim==='2D'){const r=p.sub(this.pos);this.angVel+=r.cross(j)*this.invInertia}}integrate(dt){if(this.isStatic||this.isSleeping)return;this.acc=this.force.mul(this.invMass);this.vel=this.vel.add(this.acc.mul(dt));this.pos=this.pos.add(this.vel.mul(dt));if(this.dim==='2D'){this.angAcc=this.torque*this.invInertia;this.angVel+=this.angAcc*dt;this.angle+=this.angVel*dt}this.force=this.dim==='2D'?new V2():new V3();this.torque=0}updateSleep(dt){if(this.isStatic)return;const v2=this.vel.len2(),w2=this.angVel*this.angVel;if(v2+w2<this.velThreshold*this.velThreshold){this.sleepTime+=dt;if(this.sleepTime>0.5)this.isSleeping=true}else{this.sleepTime=0;this.isSleeping=false}}wakeUp(){this.isSleeping=false;this.sleepTime=0}getAABB(){return this.shape.getAABB(this.pos,this.angle)}getTransform(){if(this.dim==='2D'){const c=Math.cos(this.angle),s=Math.sin(this.angle);return{pos:this.pos,angle:this.angle,sin:s,cos:c}}return{pos:this.pos}}}
class Contact{constructor(a,b,normal,depth,points,tangent){this.a=a;this.b=b;this.n=normal;this.depth=depth;this.points=points||[];this.t=tangent;this.bias=0;this.jn=0;this.jt=0;this.massN=0;this.massT=0}}
function collideCircles(a,b){const d=b.pos.sub(a.pos),dist2=d.len2(),rSum=a.shape.r+b.shape.r;if(dist2>=rSum*rSum)return null;const dist=Math.sqrt(dist2);if(dist<EPSILON)return new Contact(a,b,new V2(1,0),rSum,[a.pos.clone()],new V2(0,1));const n=d.div(dist),depth=rSum-dist;return new Contact(a,b,n,depth,[a.pos.add(n.mul(a.shape.r))],n.perp())}
function collideCircleBox(c,b){const d=c.pos.sub(b.pos),local=d.rot(-b.angle),hw=b.shape.w/2,hh=b.shape.h/2,closest=new V2(clamp(local.x,-hw,hw),clamp(local.y,-hh,hh)),cw=closest.rot(b.angle).add(b.pos),delta=c.pos.sub(cw),dist2=delta.len2();if(dist2>=c.shape.r*c.shape.r)return null;const dist=Math.sqrt(dist2);if(dist<EPSILON)return new Contact(c,b,new V2(0,-1),c.shape.r,[cw],new V2(1,0));const n=delta.div(dist),depth=c.shape.r-dist;return new Contact(c,b,n,depth,[cw],n.perp())}
function projectBox(b,axis){const hw=b.shape.w/2,hh=b.shape.h/2,corners=[new V2(-hw,-hh),new V2(hw,-hh),new V2(hw,hh),new V2(-hw,hh)];let min=Infinity,max=-Infinity;for(let i=0;i<4;i++){const wc=corners[i].rot(b.angle).add(b.pos),proj=wc.dot(axis);if(proj<min)min=proj;if(proj>max)max=proj}return[min,max]}
function collideBoxes(a,b){const axes=[new V2(Math.cos(a.angle),Math.sin(a.angle)),new V2(-Math.sin(a.angle),Math.cos(a.angle)),new V2(Math.cos(b.angle),Math.sin(b.angle)),new V2(-Math.sin(b.angle),Math.cos(b.angle))];let minDepth=Infinity,minAxis=null;for(let i=0;i<4;i++){const axis=axes[i],[minA,maxA]=projectBox(a,axis),[minB,maxB]=projectBox(b,axis),overlap=Math.min(maxA,maxB)-Math.max(minA,minB);if(overlap<EPSILON)return null;if(overlap<minDepth){minDepth=overlap;minAxis=axis}}const d=b.pos.sub(a.pos);if(d.dot(minAxis)<0)minAxis=minAxis.neg();const hw=a.shape.w/2,hh=a.shape.h/2,corners=[new V2(-hw,-hh),new V2(hw,-hh),new V2(hw,hh),new V2(-hw,hh)],wc=corners.map(c=>c.rot(a.angle).add(a.pos)),hw2=b.shape.w/2,hh2=b.shape.h/2,corners2=[new V2(-hw2,-hh2),new V2(hw2,-hh2),new V2(hw2,hh2),new V2(-hw2,hh2)],wc2=corners2.map(c=>c.rot(b.angle).add(b.pos)),pts=[];for(let i=0;i<4;i++){const p=wc[i],d2=p.sub(b.pos),local=d2.rot(-b.angle);if(Math.abs(local.x)<=hw2&&Math.abs(local.y)<=hh2)pts.push(p)}for(let i=0;i<4;i++){const p=wc2[i],d2=p.sub(a.pos),local=d2.rot(-a.angle);if(Math.abs(local.x)<=hw&&Math.abs(local.y)<=hh)pts.push(p)}if(pts.length===0)pts.push(a.pos.lerp(b.pos,0.5));return new Contact(a,b,minAxis,minDepth,pts,minAxis.perp())}
function collideSpheres(a,b){const d=b.pos.sub(a.pos),dist2=d.len2(),rSum=a.shape.r+b.shape.r;if(dist2>=rSum*rSum)return null;const dist=Math.sqrt(dist2);if(dist<EPSILON)return new Contact(a,b,new V3(0,1,0),rSum,[a.pos.clone()],new V3(1,0,0));const n=d.div(dist),depth=rSum-dist;return new Contact(a,b,n,depth,[a.pos.add(n.mul(a.shape.r))],null)}
function collideSphereBox(s,b){const hw=b.shape.w/2,hh=b.shape.h/2,hd=b.shape.d/2,closest=new V3(clamp(s.pos.x,b.pos.x-hw,b.pos.x+hw),clamp(s.pos.y,b.pos.y-hh,b.pos.y+hh),clamp(s.pos.z,b.pos.z-hd,b.pos.z+hd)),delta=s.pos.sub(closest),dist2=delta.len2();if(dist2>=s.shape.r*s.shape.r)return null;const dist=Math.sqrt(dist2);if(dist<EPSILON)return new Contact(s,b,new V3(0,1,0),s.shape.r,[closest],null);const n=delta.div(dist),depth=s.shape.r-dist;return new Contact(s,b,n,depth,[closest],null)}
function collideBoxes3D(a,b){const aabb1=a.getAABB(),aabb2=b.getAABB();if(!aabb1.overlaps(aabb2))return null;const ox=Math.min(aabb1.max.x,aabb2.max.x)-Math.max(aabb1.min.x,aabb2.min.x),oy=Math.min(aabb1.max.y,aabb2.max.y)-Math.max(aabb1.min.y,aabb2.min.y),oz=Math.min(aabb1.max.z,aabb2.max.z)-Math.max(aabb1.min.z,aabb2.min.z);let n,depth;if(ox<oy&&ox<oz){depth=ox;n=a.pos.x<b.pos.x?new V3(-1,0,0):new V3(1,0,0)}else if(oy<oz){depth=oy;n=a.pos.y<b.pos.y?new V3(0,-1,0):new V3(0,1,0)}else{depth=oz;n=a.pos.z<b.pos.z?new V3(0,0,-1):new V3(0,0,1)}return new Contact(a,b,n,depth,[a.pos.lerp(b.pos,0.5)],null)}
function narrowphase(a,b){if(a.dim==='2D'){if(a.shape.type==='circle'&&b.shape.type==='circle')return collideCircles(a,b);if(a.shape.type==='circle'&&b.shape.type==='box'){const c=collideCircleBox(a,b);return c}if(a.shape.type==='box'&&b.shape.type==='circle'){const c=collideCircleBox(b,a);if(c){c.n=c.n.neg();[c.a,c.b]=[c.b,c.a]}return c}if(a.shape.type==='box'&&b.shape.type==='box')return collideBoxes(a,b)}else{if(a.shape.type==='sphere'&&b.shape.type==='sphere')return collideSpheres(a,b);if(a.shape.type==='sphere'&&b.shape.type==='cube'){const c=collideSphereBox(a,b);return c}if(a.shape.type==='cube'&&b.shape.type==='sphere'){const c=collideSphereBox(b,a);if(c){c.n=c.n.neg();[c.a,c.b]=[c.b,c.a]}return c}if(a.shape.type==='cube'&&b.shape.type==='cube')return collideBoxes3D(a,b)}return null}
function preSolve(c){const a=c.a,b=c.b,invMass=a.invMass+b.invMass;if(invMass<EPSILON)return;const e=Math.min(a.mat.restitution,b.mat.restitution),rv=b.vel.sub(a.vel),vn=rv.dot(c.n);c.bias=0;if(vn<-1)c.bias=-e*vn;c.massN=1/invMass;if(c.t){const vt=rv.dot(c.t);c.massT=1/invMass}}
function solve(c){const a=c.a,b=c.b;if(a.isStatic&&b.isStatic)return;const invMass=a.invMass+b.invMass;if(invMass<EPSILON)return;const correction=c.n.mul(c.depth*0.4/invMass);if(!a.isStatic)a.pos=a.pos.sub(correction.mul(a.invMass));if(!b.isStatic)b.pos=b.pos.add(correction.mul(b.invMass));const rv=b.vel.sub(a.vel),vn=rv.dot(c.n),dvn=vn-c.bias;let jn=-dvn*c.massN;const jn0=c.jn;c.jn=Math.max(jn0+jn,0);jn=c.jn-jn0;const impulseN=c.n.mul(jn);if(!a.isStatic)a.vel=a.vel.sub(impulseN.mul(a.invMass));if(!b.isStatic)b.vel=b.vel.add(impulseN.mul(b.invMass));if(c.t){const rv2=b.vel.sub(a.vel),vt=rv2.dot(c.t);let jt=-vt*c.massT;const maxFriction=Math.sqrt(a.mat.staticFriction*b.mat.staticFriction)*c.jn;const jt0=c.jt;c.jt=clamp(jt0+jt,-maxFriction,maxFriction);jt=c.jt-jt0;const impulseT=c.t.mul(jt);if(!a.isStatic)a.vel=a.vel.sub(impulseT.mul(a.invMass));if(!b.isStatic)b.vel=b.vel.add(impulseT.mul(b.invMass))}}
class SpatialHash{constructor(cellSize=100){this.cellSize=cellSize;this.cells=new Map()}clear(){this.cells.clear()}_hash(x,y,z=0){const ix=Math.floor(x/this.cellSize),iy=Math.floor(y/this.cellSize),iz=Math.floor(z/this.cellSize);return`${ix},${iy},${iz}`}insert(body){const aabb=body.getAABB(),minKey=this._hash(aabb.min.x,aabb.min.y,aabb.min.z||0),maxKey=this._hash(aabb.max.x,aabb.max.y,aabb.max.z||0),[minX,minY,minZ]=minKey.split(',').map(Number),[maxX,maxY,maxZ]=maxKey.split(',').map(Number);for(let x=minX;x<=maxX;x++)for(let y=minY;y<=maxY;y++)for(let z=minZ;z<=maxZ;z++){const k=`${x},${y},${z}`;if(!this.cells.has(k))this.cells.set(k,[]);this.cells.get(k).push(body)}}getPairs(){const pairs=[],tested=new Set();for(const bodies of this.cells.values())for(let i=0;i<bodies.length;i++)for(let j=i+1;j<bodies.length;j++){const a=bodies[i],b=bodies[j],key=a.id<b.id?`${a.id}-${b.id}`:`${b.id}-${a.id}`;if(!tested.has(key)){tested.add(key);pairs.push([a,b])}}return pairs}}
class PhysicsWorld{constructor(dim='2D',opt={}){this.dim=dim;this.bodies=[];this.gravity=opt.gravity||(dim==='2D'?new V2(0,500):new V3(0,-500,0));this.iterations=opt.iterations||8;this.damping=opt.damping??0.999;this.spatialHash=new SpatialHash(opt.cellSize||120);this.contacts=[];this.time=0}addBody(body){body.dim=this.dim;this.bodies.push(body);return body}removeBody(body){const idx=this.bodies.indexOf(body);if(idx!==-1)this.bodies.splice(idx,1)}step(dt){const subSteps=2,subDt=dt/subSteps;for(let s=0;s<subSteps;s++){for(const b of this.bodies)if(!b.isStatic&&!b.isSleeping)b.applyForce(this.gravity.mul(b.mass));for(const b of this.bodies)b.integrate(subDt);this.spatialHash.clear();for(const b of this.bodies)this.spatialHash.insert(b);const pairs=this.spatialHash.getPairs();this.contacts=[];for(const[a,b]of pairs){if(a.isStatic&&b.isStatic)continue;if(!a.getAABB().overlaps(b.getAABB()))continue;const c=narrowphase(a,b);if(c)this.contacts.push(c)}for(const c of this.contacts)preSolve(c);for(let i=0;i<this.iterations;i++)for(const c of this.contacts)solve(c);for(const b of this.bodies){b.vel=b.vel.mul(this.damping);b.updateSleep(subDt)}}this.time+=dt}queryPoint(p,r=0){const results=[];for(const b of this.bodies){const d=b.pos.dist(p);if(d<=r+(b.shape.r||0))results.push(b)}return results}queryAABB(aabb){const results=[];for(const b of this.bodies)if(b.getAABB().overlaps(aabb))results.push(b);return results}raycast(origin,dir,maxDist=1000){let closest=null,minT=maxDist;for(const b of this.bodies){let t=Infinity;if(this.dim==='2D'&&b.shape.type==='circle'){const oc=origin.sub(b.pos),a=dir.dot(dir),hb=oc.dot(dir),c=oc.dot(oc)-b.shape.r*b.shape.r,disc=hb*hb-a*c;if(disc>=0){const sqd=Math.sqrt(disc);t=(-hb-sqd)/a;if(t<0)t=(-hb+sqd)/a}}else if(this.dim==='3D'&&b.shape.type==='sphere'){const oc=origin.sub(b.pos),a=dir.dot(dir),hb=oc.dot(dir),c=oc.dot(oc)-b.shape.r*b.shape.r,disc=hb*hb-a*c;if(disc>=0){const sqd=Math.sqrt(disc);t=(-hb-sqd)/a;if(t<0)t=(-hb+sqd)/a}}if(t>0&&t<minT){minT=t;closest={body:b,point:origin.add(dir.mul(t)),distance:t}}}return closest}}
class Renderer{constructor(canvas,world){this.canvas=canvas;this.ctx=canvas.getContext('2d',{alpha:false});this.world=world;this.camera={pos:world.dim==='2D'?new V2(0,0):new V3(0,0,500),zoom:1,angle:0};this.lightDir=new V3(0.5,0.7,0.3).norm();this.ambientLight=0.3;this.shadows=true;this.antialiasing=true;this.particleSys=[];this.trails=new Map();this.debugDraw=false;this.stats={fps:0,bodies:0,contacts:0};this.lastTime=0;this.frameCount=0;this.fpsTime=0;if(this.antialiasing){this.ctx.imageSmoothingEnabled=true;this.ctx.imageSmoothingQuality='high'}}setCamera(pos,zoom,angle){if(pos)this.camera.pos=pos;if(zoom!==undefined)this.camera.zoom=zoom;if(angle!==undefined)this.camera.angle=angle}worldToScreen(p){if(this.world.dim==='2D'){const rel=p.sub(this.camera.pos),scaled=rel.mul(this.camera.zoom),rotated=scaled.rot(this.camera.angle);return new V2(this.canvas.width/2+rotated.x,this.canvas.height/2+rotated.y)}else{const rel=p.sub(this.camera.pos),z=rel.z||0,scale=300/(300+z)*this.camera.zoom;return new V2(this.canvas.width/2+rel.x*scale,this.canvas.height/2-rel.y*scale)}}clear(){this.ctx.fillStyle='#0a0e1a';this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)}drawGrid(){const ctx=this.ctx,w=this.canvas.width,h=this.canvas.height;ctx.strokeStyle='rgba(100,120,150,0.15)';ctx.lineWidth=1;const gridSize=50*this.camera.zoom;for(let x=0;x<w;x+=gridSize){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,h);ctx.stroke()}for(let y=0;y<h;y+=gridSize){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w,y);ctx.stroke()}}drawBody2D(body){const ctx=this.ctx,sp=this.worldToScreen(body.pos),shape=body.shape;ctx.save();ctx.translate(sp.x,sp.y);ctx.rotate(body.angle);const glow=!body.isStatic&&!body.isSleeping;if(glow){const grad=ctx.createRadialGradient(0,0,0,0,0,shape.r*this.camera.zoom*1.5);grad.addColorStop(0,body.mat.color+'44');grad.addColorStop(1,body.mat.color+'00');ctx.fillStyle=grad;ctx.beginPath();ctx.arc(0,0,shape.r*this.camera.zoom*1.5,0,PI2);ctx.fill()}if(shape.type==='circle'){const r=shape.r*this.camera.zoom;const grad=ctx.createRadialGradient(-r*0.3,-r*0.3,0,0,0,r);grad.addColorStop(0,this.lightenColor(body.mat.color,30));grad.addColorStop(1,body.mat.color);ctx.fillStyle=grad;ctx.beginPath();ctx.arc(0,0,r,0,PI2);ctx.fill();ctx.strokeStyle=this.darkenColor(body.mat.color,30);ctx.lineWidth=2;ctx.stroke();ctx.strokeStyle='rgba(255,255,255,0.5)';ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(r,0);ctx.stroke()}else if(shape.type==='box'){const hw=shape.w/2*this.camera.zoom,hh=shape.h/2*this.camera.zoom;const grad=ctx.createLinearGradient(-hw,-hh,hw,hh);grad.addColorStop(0,this.lightenColor(body.mat.color,20));grad.addColorStop(1,body.mat.color);ctx.fillStyle=grad;ctx.fillRect(-hw,-hh,hw*2,hh*2);ctx.strokeStyle=this.darkenColor(body.mat.color,40);ctx.lineWidth=2;ctx.strokeRect(-hw,-hh,hw*2,hh*2);ctx.strokeStyle='rgba(255,255,255,0.3)';ctx.lineWidth=1;ctx.strokeRect(-hw+2,-hh+2,hw*2-4,hh*2-4)}if(body.isSleeping){ctx.fillStyle='rgba(100,150,255,0.2)';if(shape.type==='circle'){ctx.beginPath();ctx.arc(0,0,shape.r*this.camera.zoom,0,PI2);ctx.fill()}else{const hw=shape.w/2*this.camera.zoom,hh=shape.h/2*this.camera.zoom;ctx.fillRect(-hw,-hh,hw*2,hh*2)}}ctx.restore()}drawBody3D(body){const ctx=this.ctx,sp=this.worldToScreen(body.pos),shape=body.shape,z=body.pos.z||0,scale=300/(300+z)*this.camera.zoom;if(z>500)return;ctx.save();const brightness=clamp(0.3+z*0.001,0.3,1.2);const shadowAlpha=clamp(0.4-z*0.001,0,0.4);if(this.shadows){ctx.fillStyle=`rgba(0,0,0,${shadowAlpha})`;if(shape.type==='sphere'){const r=shape.r*scale*1.3;ctx.beginPath();ctx.ellipse(sp.x,this.canvas.height*0.9,r,r*0.4,0,0,PI2);ctx.fill()}else if(shape.type==='cube'){const hw=shape.w/2*scale,hd=shape.d/2*scale;ctx.fillRect(sp.x-hw,this.canvas.height*0.9-5,hw*2,10)}}ctx.translate(sp.x,sp.y);const col=this.adjustBrightness(body.mat.color,brightness);if(shape.type==='sphere'){const r=shape.r*scale;const grad=ctx.createRadialGradient(-r*0.3,-r*0.3,0,0,0,r);grad.addColorStop(0,this.lightenColor(col,40));grad.addColorStop(0.7,col);grad.addColorStop(1,this.darkenColor(col,30));ctx.fillStyle=grad;ctx.beginPath();ctx.arc(0,0,r,0,PI2);ctx.fill();ctx.strokeStyle=this.darkenColor(col,40);ctx.lineWidth=2;ctx.stroke();const hlSize=r*0.3;ctx.fillStyle='rgba(255,255,255,0.4)';ctx.beginPath();ctx.arc(-r*0.3,-r*0.3,hlSize,0,PI2);ctx.fill()}else if(shape.type==='cube'){const hw=shape.w/2*scale,hh=shape.h/2*scale,hd=shape.d/2*scale;const dx=hd*0.4,dy=hd*0.3;ctx.fillStyle=col;ctx.fillRect(-hw,-hh,hw*2,hh*2);ctx.strokeStyle=this.darkenColor(col,40);ctx.lineWidth=2;ctx.strokeRect(-hw,-hh,hw*2,hh*2);ctx.fillStyle=this.lightenColor(col,30);ctx.beginPath();ctx.moveTo(-hw,-hh);ctx.lineTo(-hw+dx,-hh-dy);ctx.lineTo(hw+dx,-hh-dy);ctx.lineTo(hw,-hh);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle=this.darkenColor(col,20);ctx.beginPath();ctx.moveTo(hw,-hh);ctx.lineTo(hw+dx,-hh-dy);ctx.lineTo(hw+dx,hh-dy);ctx.lineTo(hw,hh);ctx.closePath();ctx.fill();ctx.stroke()}ctx.restore()}drawContacts(){if(!this.debugDraw)return;const ctx=this.ctx;for(const c of this.world.contacts){for(const p of c.points){const sp=this.worldToScreen(p);ctx.fillStyle='#ff0000';ctx.beginPath();ctx.arc(sp.x,sp.y,4,0,PI2);ctx.fill()}const cp=c.points[0]||c.a.pos,sp=this.worldToScreen(cp),ep=this.worldToScreen(cp.add(c.n.mul(30)));ctx.strokeStyle='#00ff00';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(sp.x,sp.y);ctx.lineTo(ep.x,ep.y);ctx.stroke()}}drawParticles(){const ctx=this.ctx;this.particleSys=this.particleSys.filter(p=>{p.life-=0.016;if(p.life<=0)return false;p.pos=p.pos.add(p.vel.mul(0.016));p.vel=p.vel.mul(0.98);const sp=this.worldToScreen(p.pos),alpha=p.life/p.maxLife;ctx.fillStyle=`rgba(${p.color},${alpha})`;ctx.beginPath();ctx.arc(sp.x,sp.y,p.size*this.camera.zoom,0,PI2);ctx.fill();return true})}addParticles(pos,count,color='255,200,100'){for(let i=0;i<count;i++){const angle=Math.random()*PI2,speed=50+Math.random()*100,vel=this.world.dim==='2D'?new V2(Math.cos(angle)*speed,Math.sin(angle)*speed):new V3(Math.cos(angle)*speed,Math.sin(angle)*speed,(Math.random()-0.5)*50);this.particleSys.push({pos:pos.clone(),vel,life:0.5+Math.random()*0.5,maxLife:1,size:2+Math.random()*3,color})}}drawTrails(){const ctx=this.ctx;for(const[id,trail]of this.trails){if(trail.points.length<2)continue;ctx.strokeStyle=trail.color;ctx.lineWidth=2;ctx.beginPath();const sp=this.worldToScreen(trail.points[0]);ctx.moveTo(sp.x,sp.y);for(let i=1;i<trail.points.length;i++){const p=this.worldToScreen(trail.points[i]);ctx.lineTo(p.x,p.y)}ctx.stroke()}}updateTrails(){for(const body of this.world.bodies){if(body.isStatic||body.isSleeping)continue;if(!this.trails.has(body.id)){this.trails.set(body.id,{points:[],color:body.mat.color,maxLen:30})}const trail=this.trails.get(body.id);trail.points.push(body.pos.clone());if(trail.points.length>trail.maxLen)trail.points.shift()}}drawStats(){const ctx=this.ctx;ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(10,10,200,120);ctx.fillStyle='#ffffff';ctx.font='14px monospace';ctx.fillText(`FPS: ${this.stats.fps}`,20,30);ctx.fillText(`Bodies: ${this.stats.bodies}`,20,50);ctx.fillText(`Contacts: ${this.stats.contacts}`,20,70);ctx.fillText(`Particles: ${this.particleSys.length}`,20,90);ctx.fillText(`Time: ${this.world.time.toFixed(2)}s`,20,110)}lightenColor(col,amt){const num=parseInt(col.slice(1),16),r=Math.min(255,(num>>16)+amt),g=Math.min(255,((num>>8)&0x00FF)+amt),b=Math.min(255,(num&0x0000FF)+amt);return`#${(r<<16|g<<8|b).toString(16).padStart(6,'0')}`}darkenColor(col,amt){return this.lightenColor(col,-amt)}adjustBrightness(col,factor){const num=parseInt(col.slice(1),16),r=Math.min(255,Math.floor((num>>16)*factor)),g=Math.min(255,Math.floor(((num>>8)&0x00FF)*factor)),b=Math.min(255,Math.floor((num&0x0000FF)*factor));return`#${(r<<16|g<<8|b).toString(16).padStart(6,'0')}`}render(dt){this.clear();this.drawGrid();const sortedBodies=this.world.dim==='3D'?[...this.world.bodies].sort((a,b)=>(b.pos.z||0)-(a.pos.z||0)):this.world.bodies;for(const body of sortedBodies){if(this.world.dim==='2D')this.drawBody2D(body);else this.drawBody3D(body)}this.drawParticles();this.drawContacts();this.drawStats();this.stats.bodies=this.world.bodies.length;this.stats.contacts=this.world.contacts.length;this.frameCount++;this.fpsTime+=dt;if(this.fpsTime>=1){this.stats.fps=this.frameCount;this.frameCount=0;this.fpsTime=0}}}
class Input{constructor(canvas,world,renderer){this.canvas=canvas;this.world=world;this.renderer=renderer;this.mouse={pos:null,down:false,startPos:null,button:0};this.keys=new Set();this.dragBody=null;this.dragOffset=null;this.setupEvents()}setupEvents(){this.canvas.addEventListener('mousedown',e=>this.onMouseDown(e));this.canvas.addEventListener('mousemove',e=>this.onMouseMove(e));this.canvas.addEventListener('mouseup',e=>this.onMouseUp(e));this.canvas.addEventListener('wheel',e=>this.onWheel(e));window.addEventListener('keydown',e=>this.onKeyDown(e));window.addEventListener('keyup',e=>this.onKeyUp(e))}getMouseWorld(e){const rect=this.canvas.getBoundingClientRect(),x=(e.clientX-rect.left)*(this.canvas.width/rect.width),y=(e.clientY-rect.top)*(this.canvas.height/rect.height),cx=x-this.canvas.width/2,cy=y-this.canvas.height/2;if(this.world.dim==='2D'){const rot=new V2(cx,cy).rot(-this.renderer.camera.angle),scaled=rot.div(this.renderer.camera.zoom);return this.renderer.camera.pos.add(scaled)}else{const z=0,scale=300/(300+z)*this.renderer.camera.zoom;return this.renderer.camera.pos.add(new V3(cx/scale,cy/-scale,z))}}onMouseDown(e){this.mouse.down=true;this.mouse.button=e.button;this.mouse.startPos=this.getMouseWorld(e);this.mouse.pos=this.mouse.startPos.clone();const bodies=this.world.queryPoint(this.mouse.pos,20);if(bodies.length>0){this.dragBody=bodies[0];this.dragOffset=this.dragBody.pos.sub(this.mouse.pos);this.dragBody.wakeUp()}}onMouseMove(e){this.mouse.pos=this.getMouseWorld(e);if(this.dragBody&&this.mouse.down){const targetPos=this.mouse.pos.add(this.dragOffset),delta=targetPos.sub(this.dragBody.pos);this.dragBody.vel=delta.mul(10);this.dragBody.wakeUp()}}onMouseUp(e){if(this.mouse.down&&this.mouse.startPos&&!this.dragBody){const endPos=this.getMouseWorld(e),vel=endPos.sub(this.mouse.startPos).mul(5),types=['circle','box'],shapes=this.world.dim==='2D'?[new Circle(10+Math.random()*20),new Box(20+Math.random()*40,20+Math.random()*40)]:[new Sphere(10+Math.random()*20),new Cube(20+Math.random()*40,20+Math.random()*40,20+Math.random()*40)],shape=shapes[Math.floor(Math.random()*shapes.length)],colors=['#ff6b6b','#4ecdc4','#45b7d1','#f9ca24','#6c5ce7','#fd79a8','#fdcb6e','#00b894'],mat=new Material({restitution:0.3+Math.random()*0.5,staticFriction:0.5,dynamicFriction:0.3,color:colors[Math.floor(Math.random()*colors.length)]}),body=new Body({dim:this.world.dim,shape,material:mat,pos:this.mouse.startPos.clone(),vel});this.world.addBody(body);this.renderer.addParticles(this.mouse.startPos,10)}this.mouse.down=false;this.dragBody=null;this.dragOffset=null}onWheel(e){e.preventDefault();const delta=e.deltaY*-0.001;this.renderer.camera.zoom*=1+delta;this.renderer.camera.zoom=clamp(this.renderer.camera.zoom,0.3,3)}onKeyDown(e){this.keys.add(e.key);if(e.key==='d'||e.key==='D')this.renderer.debugDraw=!this.renderer.debugDraw;if(e.key==='r'||e.key==='R'){this.world.bodies=this.world.bodies.filter(b=>b.isStatic);this.renderer.trails.clear()}if(e.key===' '){const pos=this.renderer.camera.pos.clone();if(this.world.dim==='2D')pos.y-=100;else pos.y+=100;const shape=this.world.dim==='2D'?new Circle(15):new Sphere(15),body=new Body({dim:this.world.dim,shape,material:new Material({color:'#ff6b6b',restitution:0.7}),pos,vel:this.world.dim==='2D'?new V2(0,0):new V3(0,0,0)});this.world.addBody(body)}}onKeyUp(e){this.keys.delete(e.key)}update(dt){if(this.keys.has('ArrowLeft'))this.renderer.camera.pos=this.renderer.camera.pos.add(this.world.dim==='2D'?new V2(-300*dt,0):new V3(-300*dt,0,0));if(this.keys.has('ArrowRight'))this.renderer.camera.pos=this.renderer.camera.pos.add(this.world.dim==='2D'?new V2(300*dt,0):new V3(300*dt,0,0));if(this.keys.has('ArrowUp'))this.renderer.camera.pos=this.renderer.camera.pos.add(this.world.dim==='2D'?new V2(0,-300*dt):new V3(0,300*dt,0));if(this.keys.has('ArrowDown'))this.renderer.camera.pos=this.renderer.camera.pos.add(this.world.dim==='2D'?new V2(0,300*dt):new V3(0,-300*dt,0))}}
if(typeof global!=='undefined'){global.UnifiedPhysics={V2,V3,M3,M4,AABB,Material,Shape,Circle,Box,Sphere,Cube,Body,PhysicsWorld,Renderer,Input,clamp,lerp,smoothstep}}})(typeof window!=='undefined'?window:typeof global!=='undefined'?global:this);
